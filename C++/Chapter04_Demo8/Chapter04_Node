今晚任务：
1、总结第四章知识点（明天提问）
2、开始完成“C++项目2”：要求先阅读需求，再完成Person、Voter、Candidate类的实现并测试；
3、预习第五章第1小节（明天新课）
§1 继承
    作用：1）代码复用；2）方便维护程序。
    子类成员：既有父类的成员，又有子类自己扩展的成员。子类不能直接访问父类私有成员，通过父类公有成员函数访问。
    子类的重写/覆盖和重载的区别：
        子类可以实现与父类成员函数原型相同的成员函数，称为覆盖。覆盖是函数重载的特例，覆盖发生在继承的过程中。
        重载是一个类里面实现；覆盖/重写是两个类，且是父类与子类，子类重写父类。
    继承中父类的构造函数、析构函数，子类没有继承。
    父类中又protected成员，子类中可以直接访问。
    访问权限：
        private：私有继承，子类中所有继承自父类的成员，都变成私有成员。
        protected：受保护继承，子类中继承父类public的成员，变成子类的protected成员，继承父类private成员和protected成员，访问权限不变。
        public：公有继承，所有继承父类的成员，访问权限不变。
        默认的继承方式为私有继承。
    区别：
    private成员——只能在本类中直接访问
    protected成员——只能在本类、派生类中直接访问（使用于继承关系）
    public成员——类内、类外均可访问
    继承：（private和pritected的区别）
    不同点：
    1、子类中无法直接访问父类的private成员；（通过受保护或公有的访问函数）；
    2、子类中可以直接访问父类的protected、public成员；
    相同点：二者均不可以对外访问。（除了继承以外，类外均为private。）
§2 继承的应用
    1)当两个类之间是IS-A的关系，即一个类是另外一个类的特例，用继承来实现。一般用公有继承。
    2)为了实现代码复用，也可以用继承。（两个类之间未必有内在联系）。
    3)类A想用类B的成员函数，就把A声明成B的子类，这样的话，类A就自动拥有类B的全部成员函数（除了那3个）。
    4)继承使得修改更容易。父类改动以后，子类自动随之改动，而无需在子类中改动什么。
    类之间最主要的两种关系：
    1)组合：一个类的对象是另外一个类的成员变量，一个类拥有另一个类，Has – A ，有一个。
    2)继承：一个类是另外一个类的子类，Is – A，是一个。
§3 子类中的构造、析构和赋值运算符重载函数
    子类构造函数中，子类构造函数中调用父类构造函数，初始化来自于父类的那部分成员（作用：代码重用），再初始化自己拓展的成员。
    谁的成员，归谁初始化。子类无需重复完成父类部分的工作。父类构造函数放在初始化列表。
    在拷贝构造函数里，也是父类的成员归父类初始化，把作为子类拷贝构造函数参数的那个子类对象，传递给父类的拷贝构造函数。然后再由子类自己，初始化子类的成员。
    因为析构函数无需参数，所以在子类的析构函数中，会自动调用父类的析构函数。
    调用父类中重载的赋值运算符，对子类中属于父类的成员变量进行赋值。再对属于子类的成员进行单独赋值。
    构造子类时，先执行父类的构造函数，然后执行子类的构造函数；
    析构子类时，先执行子类的析构函数，然后执行父类的析构函数。
§4 虚函数
    在函数前加上关键字virtual，即为虚函数。
    为什么用虚函数？
    当父类指针或父类引用指向子类对象，而子类中又覆盖了父类的函数，希望用父类指针或父类引用，调用到正确版本的成员函数，需要把该成员函数声明为虚函数。调用虚函数时，到底调用哪个版本，是根据调用该函数的对象本身的类型，而不是指向那个对象的指针或引用的类型。
    虚函数目的：期望父类指针（或引用），不管指向父类还是子类，在调用override函数时，可以反映真实情况。
    有了虚函数后，无需向下转型，就可以正确的用父类的指针或引用，调用到子类的函数。
    虚析构：如果一个类有子类，则这个父类的析构函数必须是虚函数，即虚析构！防止动态内存的泄漏（潜在内存泄漏）。
        虚析构，仅针对动态分配的对象。
    如果父类的成员函数是虚函数，则子类覆盖后，不写virtual，也是虚函数。
§5 动态绑定
虚函数被调用的时候，到底调用那个版本，在编译的时候无法确定，只有在执行时才能确定，此过程被称为动态绑定。
    概念：在执行过程中实现，这时会证实所传递的对象的真实类型，根据真实类型进行调用匹配的函数。
    要求：类与类之间必须是有继承关系；父类中被重写的必须是虚函数，子类必须重写或覆盖父类的虚函数；
    应用：父类的指针或引用指向子类的对象，父类的指针或引用直接调用虚函数；
    目的：为了实现多态。
§6 虚函数的实现原理
    类：虚函数->生成虚函数表
    对象：虚指针->虚函数表（第一个元素）
    影响：增加内存消耗，增加运行时间，降低运行效率。
    一般继承：无虚函数覆盖，子类的虚函数表比父类多出子类独有的虚函数；
            1）虚函数按其声明的顺序放在虚函数表中；
            2）父类虚函数在子类虚函数前面。
            有虚函数覆盖，子类的虚函数会和父类函数个数相同，子类虚函数覆盖掉父类虚函数。
            1）子类虚函数被放到了父类虚函数的位置；
            2）没有被覆盖的函数依旧。
    多重继承：无虚函数覆盖；
            1）每个父类都有自己的虚函数表；
            2）子类的虚函数放到第一个父类虚函数表的后面，其他的父类依旧。（按照继承父类的顺序）
            有虚函数覆盖；每个父类的虚函数都被子类的虚函数覆盖。
§7 多态的理解
    父类的指针指向子类的对象，在调用函数时可以调用正确的函数。
    实现多态：类与类之间必须是继承关系；子类必须重写或覆盖父类的虚函数；父类的指针或引用指向子类的对象，用父类的指针或引用调用虚函数。
    多态的好处：实现代码复用，便于代码维护。
§8 抽象基类&纯虚函数
    纯虚函数：没有函数体，不需要实现，在虚函数声明的基础上加一个等于0.例如：virtual void draw()=0;（父类不实现，子类中实现）。
    抽象类：在类的成员函数里有纯虚函数即为抽象类。（作用：给不同种类对象提供了通用接口）
    抽象基类：抽象类只能作为父类/基类来使用，所以称之为抽象基类。
    抽象类特点：
    1）不能创建对象，因为抽象类中纯虚函数没有实现。
    2）创建子类对象，必须实现抽象基类中的所有纯虚函数，否则，子类依然是抽象类。
    3）不能单独调用抽象类的构造函数，仅可用于子类构造函数的初始化列表，用来初始化子类中继承自父类的成员变量。
    4）抽象类不是必须有析构函数，一旦有，必须是虚析构函数。
    5）不能以传值的方式向一个函数传递抽象基类的参数。
§9 运行时类型识别RTTI
    RTTI类别：
    dynamic_cast：动态类型转换（子类和父类之间的多态类型转换）
    用法：dynamic_cast<类型>(变量);
    static_cast：静态类型转换（基本类型之间的类型转换）
    用法：static_cast<类型>(变量);
    const_cast：常量类型转换（去掉const属性）
    用法：const_cast<类型>(变量);
    reinterpret_cast：重新解释类型转换（32bit下，想怎么转换怎么转换）
    用法：reinterpret_cast<类型>(变量);
多态中可能发生的问题？怎么解决？
向下转型：
问题： pd=pb;  // 语法错误Error
解决办法：强制转换/静态类型转换方式->向下转型
遗留问题：父类指针始终指向父类对象时，此时仍然调用的是父类的虚函数，不能体现出子类的特征（不能实现多态性）；
解决遗留问题：只能使用动态类型转换方式
dynamic_cast与static_cast的区别？
1、dynamic_cast必须要有虚函数才能进行转换，运行时类型信息通过运算符dynamic_cast来提供。dynamic_cast用来向下转型，将基类指针转换为派生类指针。
2、static_cast静态转换即C的强制类型转换，向下转型是不安全
3、运算符dynamic_cast<T*>（ptr）用来将一个指针类型转换为另外一个指针类型。作用是它经常用来检查一个基类指针是否实际指向的是派生类对象，从而体现多态性。
const_cast该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外，type_id和expression的类型是一样的。格式如下：
const_cast<非const的type_id> (const类型变量名)
用法：
1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；
2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；
3、const_cast一般用于修改底指针，如const char *p形式。
总结：
1、动态类型转换（或者叫做动态转型）使用的机制如下：
dynamic_cast<T*>（ptr）或 dynamic_cast<T&>（rtr）
2、通常被用于：首先发生在继承关系下，用来将一个指针（引用）类型转换为另外一个指针（引用）类型。它经常用来检查一个基类指针（引用）是否实际真正的指向的是派生类对象？
3、如果直接使用派生类指针（或引用）指向基类对象时，是不安全；
此时避免此问题的发生，要用到动态类型转换才能解决此问题。
4、返回结果，如果转换不成功，则返回NULL（或0）；
如果成功，则会实现动态绑定，在此进行运行时类型的信息处理（查虚函数表）
